---
title: Study Notes
layout: default
hasSlides: false
---

<% const basePath = site.basePath %>

<div class="grid-container">
  <div class="grid-x grid-margin-x">
    <div class="cell small-10 small-offset-1 large-6 large-offset-3">
      <h2 class="h2">Thoughts on the review</h2>
      <p>I wanted to write out some notes for those of you who might be trying to figure out how to work through the review questions from the <a href="<%= basePath %>/notes/week-13/" target="_blank">last class</a>.</p>
      <hr style="height:1px">
      <section>
        <h3 class="h3">Question 1</h3>
        <blockquote>How would you design the library's database tables?</blockquote>
        <p>Look ahead to the problems you're trying to solve - how do we break down the questions until they can be answered with a formula that uses single points of data?</p>
        <p>For example, to calculate late fees, we know that the formula will be money over time, where time is the time since the book is due, and money is the fee per day.</p>
        <p><strong>Late fees are <em>what amount of money</em> multiplied by <em>what period of time</em>?</strong></p>
        <p>We know that late fees are a fixed value of money (so, a <strong>NUMBER</strong> with two decimal places) per day (a unit of <strong>time</strong>).</p>
        <p><strong>How do we know how late the book is?</strong></p>
        <p>What was the <strong>date</strong> the book was due?</p>
        <p>What is the difference between the <strong>current date</strong> and the date the book was due? This value should be formatted to the unit as the late fees use, i.e. a day.</p>
        <p>Once we have broken down our problems so that we know what data is required to answers them, we can organize that data according to the <a href="<%= basePath %>/notes/week-13/#review" target="_blank">principles</a> of database architecture.</p>
        <blockquote>Data should be duplicated as little as possible.</blockquote>
        <p>Remember that this is foundational to the purpose of an RDBMS. Look at your data - is something duplicated? Great! That means we can optimize it.</p>
        <p>When you think of the data that's going into our library database, <em>could</em> it all be put into one table? Sure! It would just be terribly inefficient. Every time someone borrowed a book, you'd have to input their whole name, address, phone number... everything about them! In order to make this more efficient, we take what we know about them and put it into a table dedicated to 'people', and then we give that record an identifier so we can reference it and get that info as often as we need.</p>
        <blockquote>One to one relationships mean we have one too many tables.</blockquote>
        <p>Do you have a table for book titles and a table for book descriptions? Since the records in those two tables each refer to a single book, we can merge those tables and get rid of the one-to-one relationship.</p>
        <blockquote>Many to many relationships mean we need a bridging table.</blockquote>
        <p>Do you have a table for authors and a table for books? Since one author can write many books, and one book can be written by many authors, how many 'author' columns do you have for a book? How many 'book' columns do you have for an author? The answer is 'uh... who knows?'. Since we don't know, and don't want to be adding columns willy-nilly, we get rid of this many-to-many relationship with a bridging table.</p>
        <p>Almost all bridging tables can be named for the relationship they describe (in this case, we could call it 'authorship'), however it's fine to have a naming convention for your bridging tables if you have trouble coming up with good names, for example booksxauthors.</p>
        <blockquote>One table for each type of entity (person, place, thing, event).</blockquote>
        <p>Look at your tables - are any of them a mix of different types of entity? Do you have multiple tables for one type of thing? If you answered 'yes' to either of these questions, why is that? If the answer is ¯\_(ツ)_/¯, then you should probably re-organize.</p>
        <blockquote>One record (cell) for (maximum) 1 datum (piece of data).</blockquote>
        <p>Good luck trying to parse lists or arrays in SQL. It's so much easier to create a new table than it is to try and shove a bunch of data into a single record. JOINs make the world go 'round!</p>
        <blockquote>We maintain referential integrity with keys.</blockquote>
        <p>This part is very important - you <em>need</em> to determine what's important in your database using keys.</p>
        <p>Primary keys are needed so that you can represent a record (an instance of an entity, say, a particular book or a particular time someone took a book out of the library) in a way that is impossible to confuse with another record, otherwise how will you know if you're refering to the right thing?</p>
        <p>Foreign keys are important so that you can represent relationships between one thing and another. Books have authors, so each book needs a <em>valid</em> reference to an author. If a book refers to an author that doesn't exist, then your data is corrupt. That's why we use foreign keys, to say 'to understand this thing, you need more information, and if that information is not accessible, something is wrong'.</p>
        <blockquote>We maintain data integrity with constraints.</blockquote>
        <p>This is where we decide what can be true in this scenario. Look at your different categories of information and determine what is possible - can books be taken out in the future? Does returning a book automatically mean that late fees are paid? Constraints let us set up the rules about what is and isn't possible, and what the consequences are for different things being true.</p>
        <blockquote>We maintain semantics with data types.</blockquote>
        <p>Going back to the example of late fees: we know that, in order to calculate late fees, we need to know an <em>amount of time</em>. Can you tell the amount of time if you're comparing the strings 'Wednesday' and 'Monday'? Which week? Which month? Which year? The database is build to answer questions with formulas. Those formulas require data of specific types. If try to provide the wrong <em>kind</em> of data to our formulas, we can't get the correct answer. <em>That</em>'s why we're specific about the types of our data.</p>
      </section>
      <hr style="height:1px">
      <section>
        <h3 class="h3">Question 2</h3>
        <blockquote>What would you use to calculate late fees?</blockquote>
        <p>We've already broken down what kind of data we need to answer this question - now we just need to decide on a mechanism, a tool that will allow us to perform this task.</p>
        <p>Think of the <em>use case</em> for this task. <em>When</em> does this calculation get performed? Perhaps a user wants to look this information up. Perhaps we want this information calculated automatically when another task (say, someone trying to borrow a book) is performed.</p>
        <p>Either way, we want to be able to answer the question 'how much does a person owe the library?'</p>
        <p>Since this is a <em>single value</em> (the amount owing), and since we may want to <em>either</em> display this value <em>or</em> use it in another block of code, the most appropriate tool is a function.</p>
        <p>Our function will find all instances of a particular person borrowing a book where the due date for the book is prior to the current date, and the book was either never returned, or was returned after the due date.</p>
        <p>The amount of time between the due date and the return (or current) date is then calculated in days<sup><a href="footnote1">1</a></sup>. This amount (of days) is added up for each book into a total number. That total is then multiplied by the fee-per-day, thus returning the total amount owing for an individual client.</p>
      </section>
      <hr style="height:1px">
      <section>
        <h3 class="h3">Question 3</h3>
        <blockquote>How would you handle renewals?</blockquote>
        <p>It would be easy to do this as a simple <code class="language-sql">UPDATE</code> statement on the due date, plus an update on a column that tracks the number of renewals of a particular book.</p>
        <p>However, since it's a good practice to <em>not</em> destroy data (in this case, the initial return date), you could do one better and create a stored procedure, as we'll be conditionally altering the data. Our stored procedure inserts a new row in the table you use to track borrowing while marking the previous instance as returned <em>if</em> there is less than two records of this client borrowing this book without a gap in time.</p>
      </section>
      <hr style="height:1px">
      <section>
        <h3 class="h3">Question 4</h3>
        <blockquote>How would you present the top 10 most borrowed books based on the genre of a patron's most recently borrowed book?</blockquote>
        <p>To find books of the same genre as the patron's last borrowed book, we can simply use a nested query - select from books where the genre is equal to (select from borrowed books with the patron's id, ordered by descending date, and fetch only 1).</p>
        <p>However, to find the top ten most borrow books, we need to be able to track how many times a book is borrowed. Now, we could use an aggregate function to sum the instances in the borrowing table grouped by book, but that would be pretty inefficient if we had to do that every time.</p>
        <p>More efficient would be to have a column in the books table where we record the number of times it is borrowed.</p>
        <p>We can update this column either using a trigger that is run whenever the book is borrowed (a row is added to the borrowing table) or using a stored procedure that captures all the data alterations associated with borrowing a book.</p>
      </section>
      <hr style="height:1px">
      <section>
        <h3 class="h3">Question 5</h3>
        <blockquote>How would you prevent a patron from borrowing a book if they had outstanding late fees of more than one dollar?</blockquote>
        <p>This is a complicated constraint. Remember how we created a function to calculate late fees? You get the value from that function, and use it in an if/else statement in a stored procedure that you use to record instances of borrowing, and throw an error based on these conditions. However you may find it less complicated to manage this constraint in a trigger that checks the function's return value before allowing your borrowing procedure to run. Keeping this constraint in its own trigger means less complicated code in your procedure.</p>
      </section>
      <hr style="height:1px">
      <section>
        <h3 class="h3">Question 6</h3>
        <blockquote>How would you generate a list of the names and phone numbers of patrons who had overdue books?</blockquote>
        <p>Again, this is a problem that is <em>mostly</em> simple - a simple select statement using the columns for 'name' and 'phone number'. How we filter those patrons, though, is less simple.</p>
        <p>Our first thought might be, since we've already been working on it, to use our function for late fees. However, the question is not about late fees - it is about overdue books. Since a person could return a book via a library dropbox, it's possible for someone to <em>not</em> have an overdue book, while still owing late fees. Therefore 'people who owe late fees' !== 'people with overdue books'.</p>
        <p>What you'll need to do is join the borrowing table and the clients table where the return date is before the current date and the book has not been returned. From this, you'll want the distinct columns showing the names and phone numbers of the patrons.</p>
      </section>
      <hr style="height:1px">
      <section>
        <h3 class="h3">Question 7</h3>
        <blockquote>How would you let a librarian waive a late fee?</blockquote>
        <p>As we talked about before, it's good practice to <em>not</em> overwrite information if that information might be useful in the future, even to contextualize other information.</p>
        <p>If you were to waive fees simply by changing the amount owing to zero, how would you know that the fee had been waived? What if some trigger was firing wrong and setting fees to zero? How would you tell what had been done correctly, and what was the result of a problem with the system?</p>
        <p>Better to associate the fee with the individual borrowing record, and have a column that records whether or not the fee had been waived.</p>
        <p>Taking this approach, we'll have to make sure that we check this column when calculating cumulative late fees!</p>
      </section>
      <hr style="height:1px">
      <section>
        <h3 class="h3">Question 8</h3>
        <blockquote>How would you see a patron's top three favourite genres?</blockquote>
        <p>This is simply a select statement, albeit a complicated one - we join the patron table, the borrowing table, and the books table, then we use an aggregate function grouped by the patron as a subquery to an aggregate function that groups by genre, sort by the count and fetch the first three rows in descending order.</p>
        <p>If this is something we knew we'd have to do more than once, for example if librarians were going to be able to call up this information as a part of a patron's 'profile', then we would certainly want to contain this complicated query within a nice, clean <code class="language-sql">VIEW</code>.</p>
      </section>
      <hr style="height:1px">
      <section>
        <h3 class="h3">Question 9</h3>
        <blockquote>How would you delete a book entirely from the system?</blockquote>
        <p>As we've talked about, it's not great to delete information that we might need later. If your library has zero copies of a book, it would be practical to simply have a 'lost/damaged' column associated with each book that could tell you if a book had been taken out of circulation.</p>
        <p>However, the question is not 'what should you do when a book is lost?' Instead, the question is about how to delete a book from the system, presumably because the library has been overtaken by fascists, and records of certain materials need to go 'underground' so that the Resistance can continue away from the prying eyes of the cruel Overlord caste and their bands of roving Mech Soldiers.</p>
        <p>So, the answer is to carefully consider what data depends on a book - we have foreign keys, obviously, in our borrowing table, authors table, etc. that would prevent deletion if we do not have a 'before' trigger that finds these records by the id that we're trying to delete and deletes the dependent records first.</p>
        <p>We must also ask the question of what associated data, if any, we want to keep - do patrons still owe fees on books that have been deleted? If so, how do we responsibly keep track of fees without having a record of what created those fees? Where could we store those fees if not in the borrowing record? If you kept the borrowing record after you had deleted a book, in order to track the associated fee, could you use your trigger to replace the book's id with an indicator that it references a deleted book?</p>
        <p>Are you starting to see why deleting information, particularly information that is central to the database's reason for being, is not a good practice?</p>
        <p>Obviously, the Resistance will need skilled DBAs, should it ever come to that.</p>
      </section>
    </div>
    <hr style="height:1px">
    <div class="cell small-10 small-offset-1 large-6 large-offset-3">
      <section id="footnote1">
        <p><small>To fully comply with the requirements of the library's fee structure, we have to loop through the 'overdue' date range and iterate our 'days' count for each day that is a weekday. I'm putting this in a footnote because it's a bit complicated, and not really something I wanted distracting you while you study. However, if you're curious, I thought I'd give you an answer.</small></p>
        <p><small>You'll need to create a placeholder number variable, followed by a for loop for the range in 1..the number of days in the range (the start day subtracted from the end day). Then, for each instance, you'll need to check if that date is a weekday.</small></p>
        <p><small>To perform this check, we use <code class="language-sql">TO_CHAR</code> to extract the day of the week from the date (including using the NLS region parameter so we don't use a type of calendar we're not expecting) for the day of the week, and check to see if that is in an array of weekdays.</small></p>
        <p><small>I think you'll find, as you progress, that dates and times are one of the most complicated types of data to handle regardless of programming language. Funny that it's something most of us find intuitive.</small></p>
      </section>
    </div>
  </div>
</div>
